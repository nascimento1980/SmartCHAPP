// Top-level imports
const express = require('express');
const router = express.Router();
const { PlanningInvite, PlanningCollaborator, VisitPlanning, User, Visit } = require('../models');
const { asyncHandler } = require('../middleware/errorHandler');
const { Op } = require('sequelize');
const auth = require('../middleware/auth');
const emailService = require('../services/EmailService');

// Middleware de autentica√ß√£o para todas as rotas
router.use(auth);

// =====================================
// GEST√ÉO DE CONVITES
// =====================================

// POST /api/planning-collaboration/invite - Enviar convite para colabora√ß√£o
router.post('/invite', asyncHandler(async (req, res) => {
  try {
    console.log('üìß Recebendo requisi√ß√£o de convite:', {
      body: req.body,
      user: req.user?.id
    });

    const { planning_id, invited_user_id, message } = req.body;

    // Validar campos obrigat√≥rios
    if (!planning_id || !invited_user_id) {
      console.log('‚ùå Campos obrigat√≥rios faltando');
      return res.status(400).json({
        error: 'Campos obrigat√≥rios',
        message: 'planning_id e invited_user_id s√£o obrigat√≥rios'
      });
    }

  // Verificar se o planejamento existe e se o usu√°rio √© o respons√°vel
  const planning = await VisitPlanning.findByPk(planning_id);
  if (!planning) {
    return res.status(404).json({
      error: 'Planejamento n√£o encontrado'
    });
  }

  // Verificar se o usu√°rio tem permiss√£o para convidar (√© o respons√°vel ou colaborador com permiss√£o)
  let hasPermission = planning.responsible_id === req.user.id;
  
  if (!hasPermission) {
    // Verificar se √© colaborador com permiss√£o de convite
    const collaborator = await PlanningCollaborator.findOne({
      where: {
        planning_id,
        user_id: req.user.id,
        is_active: true
      }
    });
    
    if (collaborator) {
      // Verificar permiss√£o can_invite no objeto permissions
      const permissions = typeof collaborator.permissions === 'string' 
        ? JSON.parse(collaborator.permissions) 
        : collaborator.permissions;
      
      hasPermission = permissions?.can_invite === true;
    }
  }

  if (!hasPermission) {
    return res.status(403).json({
      error: 'Permiss√£o negada',
      message: 'Apenas o respons√°vel pelo planejamento ou colaboradores com permiss√£o podem enviar convites'
    });
  }

  // Verificar se o usu√°rio convidado existe
  const invitedUser = await User.findByPk(invited_user_id);
  if (!invitedUser) {
    return res.status(404).json({
      error: 'Usu√°rio convidado n√£o encontrado'
    });
  }

  // Verificar se j√° existe convite pendente ou se j√° √© colaborador
  const existingInvite = await PlanningInvite.findOne({
    where: {
      planning_id,
      invited_user_id,
      status: 'pending'
    }
  });

  if (existingInvite) {
    return res.status(400).json({
      error: 'Convite j√° enviado',
      message: 'J√° existe um convite pendente para este usu√°rio neste planejamento'
    });
  }

  const existingCollaborator = await PlanningCollaborator.findOne({
    where: {
      planning_id,
      user_id: invited_user_id,
      is_active: true
    }
  });

  if (existingCollaborator) {
    return res.status(400).json({
      error: 'Usu√°rio j√° √© colaborador',
      message: 'Este usu√°rio j√° √© colaborador deste planejamento'
    });
  }

  // Criar convite
  const invite = await PlanningInvite.create({
    planning_id,
    inviter_id: req.user.id,
    invited_user_id,
    message: message || `${req.user.name} convidou voc√™ para colaborar no planejamento semanal`,
    status: 'pending'
  });

  // Buscar convite com dados relacionados
  const inviteWithData = await PlanningInvite.findByPk(invite.id, {
    include: [
      {
        model: User,
        as: 'inviter',
        attributes: ['id', 'name', 'email']
      },
      {
        model: User,
        as: 'invitedUser',
        attributes: ['id', 'name', 'email']
      },
      {
        model: VisitPlanning,
        as: 'planning',
        attributes: ['id', 'week_start_date', 'week_end_date', 'planning_type', 'status']
      }
    ]
  });

  // Enviar email de convite (n√£o bloqueante - sem await)
  try {
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
    const acceptUrl = `${frontendUrl}/planning/invites`;
    
    // Formatar per√≠odo
    const formatDate = (date) => {
      return new Date(date).toLocaleDateString('pt-BR');
    };
    
    emailService.sendCollaborationInvite({
      to: invitedUser.email,
      inviterName: req.user.name,
      invitedUserName: invitedUser.name,
      planningDetails: {
        period: `${formatDate(planning.week_start_date)} a ${formatDate(planning.week_end_date)}`,
        type: planning.planning_type === 'weekly' ? 'Semanal' : 'Mensal',
        description: message
      },
      acceptUrl
    }).catch(err => {
      console.warn('‚ö†Ô∏è Erro ao enviar email de convite (opera√ß√£o n√£o bloqueante):', err.message);
    });
  } catch (emailError) {
    // Log do erro mas n√£o bloqueia a cria√ß√£o do convite
    console.warn('‚ö†Ô∏è Erro ao preparar email de convite:', emailError.message);
  }

  res.status(201).json({
    message: 'Convite enviado com sucesso',
    invite: inviteWithData
  });
  } catch (error) {
    console.error('‚ùå Erro ao processar convite:', {
      message: error.message,
      stack: error.stack,
      body: req.body
    });
    throw error; // O asyncHandler vai pegar e retornar erro apropriado
  }
}));

// GET /api/planning-collaboration/invites/received - Listar convites recebidos
router.get('/invites/received', asyncHandler(async (req, res) => {
  const { status = 'pending' } = req.query;

  const invites = await PlanningInvite.findAll({
    where: {
      invited_user_id: req.user.id,
      ...(status !== 'all' && { status })
    },
    include: [
      {
        model: User,
        as: 'inviter',
        attributes: ['id', 'name', 'email']
      },
      {
        model: VisitPlanning,
        as: 'planning',
        attributes: ['id', 'week_start_date', 'week_end_date', 'planning_type', 'status'],
        include: [
          {
            model: User,
            as: 'responsible',
            attributes: ['id', 'name', 'email']
          }
        ]
      }
    ],
    order: [['invited_at', 'DESC']]
  });

  res.json({
    invites,
    total: invites.length
  });
}));

// GET /api/planning-collaboration/invites/sent - Listar convites enviados
router.get('/invites/sent', asyncHandler(async (req, res) => {
  const { status = 'all' } = req.query;

  const invites = await PlanningInvite.findAll({
    where: {
      inviter_id: req.user.id,
      ...(status !== 'all' && { status })
    },
    include: [
      {
        model: User,
        as: 'invitedUser',
        attributes: ['id', 'name', 'email']
      },
      {
        model: VisitPlanning,
        as: 'planning',
        attributes: ['id', 'week_start_date', 'week_end_date', 'planning_type', 'status']
      }
    ],
    order: [['invited_at', 'DESC']]
  });

  res.json({
    invites,
    total: invites.length
  });
}));

// PUT /api/planning-collaboration/invites/:id/respond - Responder convite
router.put('/invites/:id/respond', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { response, response_message } = req.body; // 'accepted' ou 'declined'

  if (!['accepted', 'declined'].includes(response)) {
    return res.status(400).json({
      error: 'Resposta inv√°lida',
      message: 'A resposta deve ser "accepted" ou "declined"'
    });
  }

  // Buscar convite
  const invite = await PlanningInvite.findByPk(id, {
    include: [
      {
        model: VisitPlanning,
        as: 'planning',
        attributes: ['id', 'week_start_date', 'week_end_date', 'planning_type', 'responsible_id']
      }
    ]
  });

  if (!invite) {
    return res.status(404).json({
      error: 'Convite n√£o encontrado'
    });
  }

  // Verificar se o usu√°rio √© o destinat√°rio do convite
  if (invite.invited_user_id !== req.user.id) {
    return res.status(403).json({
      error: 'Permiss√£o negada',
      message: 'Voc√™ s√≥ pode responder convites enviados para voc√™'
    });
  }

  // Verificar se o convite ainda est√° pendente
  if (invite.status !== 'pending') {
    return res.status(400).json({
      error: 'Convite j√° respondido',
      message: `Este convite j√° foi ${invite.status === 'accepted' ? 'aceito' : 'recusado'}`
    });
  }

  // Atualizar convite
  await invite.update({
    status: response,
    responded_at: new Date(),
    response_message: response_message || null
  });

  // Se aceito, criar colaborador e sincronizar agendamentos
  if (response === 'accepted') {
    // Criar colaborador
    await PlanningCollaborator.create({
      planning_id: invite.planning_id,
      user_id: req.user.id,
      role: 'collaborator',
      permissions: {
        can_view: true,
        can_edit: false,
        can_delete: false,
        can_invite: false,
        can_execute: false
      },
      added_by: invite.inviter_id,
      sync_to_calendar: true
    });

    // Sincronizar agendamentos (criar c√≥pias das visitas no calend√°rio do colaborador)
    await syncPlanningToCollaborator(invite.planning_id, req.user.id);
  }

  res.json({
    message: response === 'accepted' ? 'Convite aceito com sucesso' : 'Convite recusado',
    invite: {
      ...invite.toJSON(),
      status: response,
      responded_at: new Date(),
      response_message
    }
  });
}));

// =====================================
// GEST√ÉO DE COLABORADORES
// =====================================

// GET /api/planning-collaboration/:planningId/collaborators - Listar colaboradores
router.get('/:planningId/collaborators', asyncHandler(async (req, res) => {
  const { planningId } = req.params;

  // Verificar se o planejamento existe e se o usu√°rio tem acesso
  const planning = await VisitPlanning.findByPk(planningId);
  if (!planning) {
    return res.status(404).json({
      error: 'Planejamento n√£o encontrado'
    });
  }

  // Verificar permiss√£o de visualiza√ß√£o
  const hasAccess = planning.responsible_id === req.user.id ||
    await PlanningCollaborator.findOne({
      where: {
        planning_id: planningId,
        user_id: req.user.id,
        is_active: true
      }
    });

  if (!hasAccess) {
    return res.status(403).json({
      error: 'Permiss√£o negada',
      message: 'Voc√™ n√£o tem acesso a este planejamento'
    });
  }

  // Buscar colaboradores
  const collaborators = await PlanningCollaborator.findAll({
    where: {
      planning_id: planningId,
      is_active: true
    },
    include: [
      {
        model: User,
        as: 'user',
        attributes: ['id', 'name', 'email', 'role', 'department']
      },
      {
        model: User,
        as: 'addedBy',
        attributes: ['id', 'name', 'email']
      }
    ],
    order: [['added_at', 'ASC']]
  });

  // Incluir o respons√°vel principal
  const responsible = await User.findByPk(planning.responsible_id, {
    attributes: ['id', 'name', 'email', 'role', 'department']
  });

  res.json({
    collaborators,
    responsible,
    total: collaborators.length + 1 // +1 para incluir o respons√°vel
  });
}));

// PUT /api/planning-collaboration/collaborators/:id/permissions - Atualizar permiss√µes
router.put('/collaborators/:id/permissions', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { permissions } = req.body;

  // Buscar colaborador
  const collaborator = await PlanningCollaborator.findByPk(id, {
    include: [
      {
        model: VisitPlanning,
        as: 'planning',
        attributes: ['responsible_id']
      }
    ]
  });

  if (!collaborator) {
    return res.status(404).json({
      error: 'Colaborador n√£o encontrado'
    });
  }

  // Verificar se o usu√°rio √© o respons√°vel pelo planejamento
  if (collaborator.planning.responsible_id !== req.user.id) {
    return res.status(403).json({
      error: 'Permiss√£o negada',
      message: 'Apenas o respons√°vel pelo planejamento pode alterar permiss√µes'
    });
  }

  // Validar estrutura de permiss√µes
  const validPermissions = ['can_view', 'can_edit', 'can_delete', 'can_invite', 'can_execute'];
  const invalidPermissions = Object.keys(permissions).filter(p => !validPermissions.includes(p));
  
  if (invalidPermissions.length > 0) {
    return res.status(400).json({
      error: 'Permiss√µes inv√°lidas',
      message: `Permiss√µes inv√°lidas: ${invalidPermissions.join(', ')}`,
      validPermissions
    });
  }

  // Atualizar permiss√µes
  await collaborator.update({
    permissions: {
      ...collaborator.permissions,
      ...permissions
    }
  });

  res.json({
    message: 'Permiss√µes atualizadas com sucesso',
    collaborator: collaborator.toJSON()
  });
}));

// DELETE /api/planning-collaboration/collaborators/:id - Remover colaborador
router.delete('/collaborators/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;

  // Buscar colaborador
  const collaborator = await PlanningCollaborator.findByPk(id, {
    include: [
      {
        model: VisitPlanning,
        as: 'planning',
        attributes: ['responsible_id']
      }
    ]
  });

  if (!collaborator) {
    return res.status(404).json({
      error: 'Colaborador n√£o encontrado'
    });
  }

  // Verificar permiss√£o (respons√°vel ou o pr√≥prio colaborador)
  const canRemove = collaborator.planning.responsible_id === req.user.id || 
                   collaborator.user_id === req.user.id;

  if (!canRemove) {
    return res.status(403).json({
      error: 'Permiss√£o negada',
      message: 'Apenas o respons√°vel pelo planejamento ou o pr√≥prio colaborador pode remover a colabora√ß√£o'
    });
  }

  // Marcar como inativo ao inv√©s de deletar
  await collaborator.update({
    is_active: false
  });

  // Remover visitas sincronizadas do calend√°rio do colaborador
  await removeSyncedVisitsFromCollaborator(collaborator.planning_id, collaborator.user_id);

  res.json({
    message: 'Colaborador removido com sucesso'
  });
}));

// =====================================
// FUN√á√ïES AUXILIARES
// =====================================

// Sincronizar planejamento com colaborador (criar c√≥pias das visitas)
const syncPlanningToCollaborator = async (planningId, collaboratorUserId) => {
  try {
    // Buscar todas as visitas ativas do planejamento
    const visits = await Visit.findAll({
      where: {
        planning_id: planningId,
        status: { [Op.in]: ['agendada', 'em_andamento', 'planejada'] }
      }
    });

    let createdCount = 0;
    // Criar uma c√≥pia de cada visita para o colaborador
    for (const visit of visits) {
      // Verificar se j√° existe uma c√≥pia sincronizada
      const existingSync = await Visit.findOne({
        where: {
          responsible_id: collaboratorUserId,
          scheduled_date: visit.scheduled_date,
          scheduled_time: visit.scheduled_time,
          source: `sync_${visit.id}` // Identificador de sincroniza√ß√£o
        }
      });

      if (!existingSync) {
        await Visit.create({
          title: `[SYNC] ${visit.title}`,
          type: visit.type,
          scheduled_date: visit.scheduled_date,
          scheduled_time: visit.scheduled_time,
          address: visit.address,
          notes: `Compromisso sincronizado do planejamento compartilhado. Original: ${visit.title}`,
          priority: visit.priority,
          estimated_duration: visit.estimated_duration,
          status: 'planejada', // Status espec√≠fico para sincronizados
          responsible_id: collaboratorUserId,
          planning_id: planningId,
          client_id: visit.client_id,
          lead_id: visit.lead_id,
          client_name: visit.client_name,
          client_address: visit.client_address,
          visit_type: visit.visit_type,
          source: `sync_${visit.id}` // Identificador de sincroniza√ß√£o
        });
        createdCount++;
      }
    }

    // Atualizar data de sincroniza√ß√£o
    await PlanningCollaborator.update(
      { last_sync_at: new Date() },
      {
        where: { planning_id: planningId, user_id: collaboratorUserId }
      }
    );
    broadcast({ type: 'visit.created', payload: { planning_id: planningId, responsible_id: collaboratorUserId, batch: true, count: createdCount } });
  } catch (error) {
    console.error('Erro ao sincronizar planejamento:', error);
    throw error;
  }
};

// Remover visitas sincronizadas do colaborador
const removeSyncedVisitsFromCollaborator = async (planningId, collaboratorUserId) => {
  try {
    // Buscar visitas originais do planejamento
    const originalVisits = await Visit.findAll({
      where: {
        planning_id: planningId,
        responsible_id: { [Op.ne]: collaboratorUserId } // N√£o √© do colaborador
      },
      attributes: ['id']
    });

    // Remover visitas sincronizadas
    const syncSources = originalVisits.map(v => `sync_${v.id}`);
    const deletedCount = await Visit.destroy({
      where: {
        responsible_id: collaboratorUserId,
        source: { [Op.in]: syncSources }
      }
    });
    broadcast({ type: 'visit.deleted', payload: { planning_id: planningId, responsible_id: collaboratorUserId, batch: true, count: deletedCount } });
  } catch (error) {
    console.error('Erro ao remover visitas sincronizadas:', error);
    throw error;
  }
};

module.exports = router;


